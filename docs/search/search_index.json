{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 This is a collection of code illustration of Toney Group . Free feel to contact me at zizh7255@colorado.edu . The design of this site is based on emptymalei/deep-learning from datumorphism . An example of what you can do here: \u00b6 A subsection \u00b6 LaTeX: $$ \\begin{equation} \\int _{\\text{x-ray}}^{\\text{Neutron}}\\text{Synchrotron}=??? \\end{equation} $$ Figure: Fig 1. This is a Synchrotron. Box: Neutron Neutron is Neutron X-ray X-ray is X-ray Synchrotron Synchrotron is Synchrotron Code Another Code import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage Hello World !!! Contributors to Wikimedia projects. F-divergence. In: Wikipedia [Internet]. 17 Jul 2021 [cited 6 Sep 2021]. Available: https://en.wikipedia.org/wiki/F-divergence#Instances_of_f-divergences \u21a9 Nowozin S, Cseke B, Tomioka R. f-GAN: Training Generative Neural Samplers using Variational Divergence Minimization. arXiv [stat.ML]. 2016. Available: http://arxiv.org/abs/1606.00709 \u21a9 Contributors to Wikimedia projects. Convex conjugate. In: Wikipedia [Internet]. 20 Feb 2021 [cited 7 Sep 2021]. Available: https://en.wikipedia.org/wiki/Convex_conjugate \u21a9","title":"Home"},{"location":"#introduction","text":"This is a collection of code illustration of Toney Group . Free feel to contact me at zizh7255@colorado.edu . The design of this site is based on emptymalei/deep-learning from datumorphism .","title":"Introduction"},{"location":"#an-example-of-what-you-can-do-here","text":"","title":"An example of what you can do here:"},{"location":"#a-subsection","text":"LaTeX: $$ \\begin{equation} \\int _{\\text{x-ray}}^{\\text{Neutron}}\\text{Synchrotron}=??? \\end{equation} $$ Figure: Fig 1. This is a Synchrotron. Box: Neutron Neutron is Neutron X-ray X-ray is X-ray Synchrotron Synchrotron is Synchrotron Code Another Code import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage Hello World !!! Contributors to Wikimedia projects. F-divergence. In: Wikipedia [Internet]. 17 Jul 2021 [cited 6 Sep 2021]. Available: https://en.wikipedia.org/wiki/F-divergence#Instances_of_f-divergences \u21a9 Nowozin S, Cseke B, Tomioka R. f-GAN: Training Generative Neural Samplers using Variational Divergence Minimization. arXiv [stat.ML]. 2016. Available: http://arxiv.org/abs/1606.00709 \u21a9 Contributors to Wikimedia projects. Convex conjugate. In: Wikipedia [Internet]. 20 Feb 2021 [cited 7 Sep 2021]. Available: https://en.wikipedia.org/wiki/Convex_conjugate \u21a9","title":"A subsection"},{"location":"tags/","text":"Tags \u00b6 Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"},{"location":"GIWAXS/GIWAXS%20Index%20tool/","text":"GIWAXS index tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) & Keith White ( Keith.White@colorado.edu ) This is a python code to show the Bragg peak position and the Miller index on a 2D image (q \\(_{xy}\\) , q \\(_{z}\\) ). The program is based on GIWAXS simulation tool. You need to download diffraction.py to use the functions. The Bragg peak position is calculated using cif file. They are labeled as (h k l) on the image and the experiment data is used as background for comparison. Fig 1. This is the 2D image generated from the GIWAXS index tool. The background is simulation instead of experiment for illustration. The left row is not labeled because a cutoff of intensity is used to eliminate the peaks with low intensity. To plot the Miller index and their positions, you will need Bragg_peaks functions to calculate the Bragg peaks first and then call Mindexing function to make the 2D figure. The code and the workflow are attached below. Library Define the 'Mindexing' function Parameters Main import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects def Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ): simuposi = np . zeros ([ 100 , 2 ]) isimuposi = 0 fig , ax = plt . subplots ( figsize = fsize ) plt . imshow ( data , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = qrange , vmax = colorbar * data . max (), vmin = data . min ()) plt . xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) plt . ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) MaxI = 0 for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : MaxI = np . maximum ( I_miller [ h , k , l ], MaxI ) for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : if I_miller [ h , k , l ] > Cutoff_I * MaxI : plt . plot ( Mqxy [ h , k , l ], Mqz [ h , k , l ], 'ko' ) simuposi [ isimuposi , 0 ] = Mqxy [ h , k , l ] simuposi [ isimuposi , 1 ] = Mqz [ h , k , l ] isimuposi = isimuposi + 1 textstr = '(' + str ( h - hkl_dimension ) + ',' + str ( k - hkl_dimension ) + ',' + str ( - l + hkl_dimension ) + ')' millerplt = plt . text ( Mqxy [ h , k , l ] / ( 2 * qxymax ) + 0.5 , ( Mqz [ h , k , l ] - qzmin ) / ( qzmax - qzmin ), textstr , transform = ax . transAxes , fontsize = 10 , verticalalignment = 'top' , color = 'w' ) millerplt . set_path_effects ([ path_effects . Stroke ( linewidth = 3 , foreground = 'black' ), path_effects . Normal ()]) return simuposi data = II1 # This is the background/experiment data. data = np . log ( II1 + 1 ) colorbar = 0.9 fsize = ( 30 , 30 ) # You need a large figure to see the index. qrange = [ - qxymax , qxymax , qzmin , qzmax ] # This is the q range of your experiment data. Mindexrange = np . linspace ( 0 , hkl_dimension , hkl_dimension + 1 ) # Only the left side of the image is labeled Mindexrange = Mindexrange . astype ( 'int' ) Cutoff_I = 0.001 # Set the cutoff to eliminate the low intensity peaks dirr = '' filename = '' address = dirr + filename + '.vasp' thetax = np . pi / 2 * 0 thetay = np . pi / 2 * 0 hkl_dimension = 5 a1 , a2 , a3 , positions = diff . read_poscar ( address ) Bpeaks , Mqxy , Mqz , I_miller = diff . Bragg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) simuposi = Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ) print ( simuposi ) Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Mindexing Input2 --> Mindexing Input2: Input Input2: Experiment data Input2: Cutoff Intensity Input2: figure size Mindexing --> 2d 2d: 2d image display","title":"GIWAXS index tool"},{"location":"GIWAXS/GIWAXS%20Index%20tool/#giwaxs-index-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) & Keith White ( Keith.White@colorado.edu ) This is a python code to show the Bragg peak position and the Miller index on a 2D image (q \\(_{xy}\\) , q \\(_{z}\\) ). The program is based on GIWAXS simulation tool. You need to download diffraction.py to use the functions. The Bragg peak position is calculated using cif file. They are labeled as (h k l) on the image and the experiment data is used as background for comparison. Fig 1. This is the 2D image generated from the GIWAXS index tool. The background is simulation instead of experiment for illustration. The left row is not labeled because a cutoff of intensity is used to eliminate the peaks with low intensity. To plot the Miller index and their positions, you will need Bragg_peaks functions to calculate the Bragg peaks first and then call Mindexing function to make the 2D figure. The code and the workflow are attached below. Library Define the 'Mindexing' function Parameters Main import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects def Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ): simuposi = np . zeros ([ 100 , 2 ]) isimuposi = 0 fig , ax = plt . subplots ( figsize = fsize ) plt . imshow ( data , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = qrange , vmax = colorbar * data . max (), vmin = data . min ()) plt . xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) plt . ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) MaxI = 0 for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : MaxI = np . maximum ( I_miller [ h , k , l ], MaxI ) for h in Mindexrange : for k in Mindexrange : for l in Mindexrange : if Mqxy [ h , k , l ] < qxymax and Mqz [ h , k , l ] > qzmin and Mqz [ h , k , l ] < qzmax : if I_miller [ h , k , l ] > Cutoff_I * MaxI : plt . plot ( Mqxy [ h , k , l ], Mqz [ h , k , l ], 'ko' ) simuposi [ isimuposi , 0 ] = Mqxy [ h , k , l ] simuposi [ isimuposi , 1 ] = Mqz [ h , k , l ] isimuposi = isimuposi + 1 textstr = '(' + str ( h - hkl_dimension ) + ',' + str ( k - hkl_dimension ) + ',' + str ( - l + hkl_dimension ) + ')' millerplt = plt . text ( Mqxy [ h , k , l ] / ( 2 * qxymax ) + 0.5 , ( Mqz [ h , k , l ] - qzmin ) / ( qzmax - qzmin ), textstr , transform = ax . transAxes , fontsize = 10 , verticalalignment = 'top' , color = 'w' ) millerplt . set_path_effects ([ path_effects . Stroke ( linewidth = 3 , foreground = 'black' ), path_effects . Normal ()]) return simuposi data = II1 # This is the background/experiment data. data = np . log ( II1 + 1 ) colorbar = 0.9 fsize = ( 30 , 30 ) # You need a large figure to see the index. qrange = [ - qxymax , qxymax , qzmin , qzmax ] # This is the q range of your experiment data. Mindexrange = np . linspace ( 0 , hkl_dimension , hkl_dimension + 1 ) # Only the left side of the image is labeled Mindexrange = Mindexrange . astype ( 'int' ) Cutoff_I = 0.001 # Set the cutoff to eliminate the low intensity peaks dirr = '' filename = '' address = dirr + filename + '.vasp' thetax = np . pi / 2 * 0 thetay = np . pi / 2 * 0 hkl_dimension = 5 a1 , a2 , a3 , positions = diff . read_poscar ( address ) Bpeaks , Mqxy , Mqz , I_miller = diff . Bragg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) simuposi = Mindexing ( data , colorbar , fsize , qrange , Mindexrange , I_miller , Cutoff_I , Mqxy , Mqz ) print ( simuposi ) Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Mindexing Input2 --> Mindexing Input2: Input Input2: Experiment data Input2: Cutoff Intensity Input2: figure size Mindexing --> 2d 2d: 2d image display","title":"GIWAXS index tool in Python"},{"location":"GIWAXS/GIWAXS%20Simulation/","text":"GIWAXS Simulation tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) A program for 2D material diffraction simulation is introduced in this work. The sample is considered as crystallites with a Gaussian distribution in orientation in spherical coordinate (r, \\(\\theta\\) , \\(\\phi\\) ). The simulated diffraction pattern is in (q \\(_x\\) , q \\(_{xy}\\) ) plane which is designed to compare with WAXS(wide angle x-ray scattering) measurement. Thus Braggg peaks elongates in a ring pattern from their original positions in reciprocal space. Fig 1. (a) Crystal structure of 2D perovskite; (b) GIWAXS data of PPA; (c) GIWAXS simulation of PPA. Diffraction Intensity \u00b6 In reciprocal space, the Gaussian distribution in crystallites orientation results in a rotation for each Bragg peak. If we consider using an area detector to measure the diffraction intensity in q \\(_z\\) q \\(_{x}\\) plane. It is a summation of all Bragg peaks with each of them has the same Gaussian width( \\(\\sigma_\\theta\\) , \\(\\sigma_\\phi\\) ) centered in (q \\(_x\\) , q \\(_y\\) , q \\(_z\\) ): \\[ \\begin{equation} I(q_z,q_{x})=\\sum_{h,k,l}|\\sum_{i} f_i(\\mathbf{Q}) e^{i\\mathbf{Q}\\cdot\\mathbf{r}_n}|^2 e^{-\\frac{1}{2}\\frac{(\\theta^I-\\theta_0^B)^2}{\\sigma_\\theta^2}}e^{-\\frac{1}{2}\\frac{(\\phi^I-\\phi_0^B)^2}{\\sigma_\\phi^2}}e^{-\\frac{1}{2}\\frac{(q^I-q_0^B)^2}{\\sigma_q^2}} \\end{equation} \\] where ( \\(q^I\\) , \\(\\theta^I\\) , \\(\\phi^I\\) ) is the position of image plane(q \\(_x\\) , q \\(_z\\) ) in spherical coordinate. Fig 2. Spherical Coordinate \\[ \\begin{equation} q=\\sqrt{q_z^2+q_{x}^2},\\quad \\theta=\\frac{\\pi}{2}-\\arctan\\frac{q_z}{|q_{x}|}, \\quad \\phi= \\left\\{ \\begin{array}{cc} 0, \\quad x>0\\\\ \\pi,\\quad x<0 \\end{array} \\right. \\end{equation} \\] \\(\\mathbf{Q}\\) is the position of Bragg peaks and (hkl) is Miller index. \\(n\\) indicate the atoms in the unit cell and r \\(_n\\) is the real space position of \\(n\\) th atom in the unit cell. \\[ \\begin{equation} \\mathbf{Q}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] ( \\(q_0^B\\) , \\(\\theta_0^B\\) , \\(\\phi_0^B\\) ) is the position of Bragg peaks in reciprocal space converted to spherical coordinates: \\[ \\begin{equation} q_0^B=|\\mathbf{Q}|,\\quad\\theta_0^B=\\arctan\\frac{Q_z}{\\sqrt{Q_x^2+Q_y^2}},\\quad\\phi_0^B=\\arccos\\frac{Q_y}{\\sqrt{Q_x^2+Q_y^2}} \\end{equation} \\] It should be noticed that this is a theoretical result in (q \\(_z\\) ,q \\(_x\\) ) plane. Diffraction Ewald sphere is not considered here. Thus there is no 'missing wadge' as it always appears in GIWAXS. And a Gaussion profile in \\(\\hat{q}\\) direction is added to make a finite peak width in 2D image plane. In real materials the line shape in \\(\\hat{q}\\) is Lorentizian which depends on strain and crystallite size. Bragg Peaks \u00b6 Although we aim at 2D material in this proposal, a 3D crystal structure is needed to calculate the Bragg peaks. If the position of atoms is described in 2D, we need to assume a lattice constant or d-spacing in z-direction. The single crystal Bragg peaks are calculated from crystal structure file(.cif, POSCAR et. al) where lattice parameters and the positions of atoms in real space are provided. POSCAR File Sn2 O4 1.0 4.7648180450000002 0.0000000000000000 0.0000000000000003 0.0000000000000008 4.7648180450000002 0.0000000000000003 0.0000000000000000 0.0000000000000000 3.2074997700000001 Sn O 2 4 direct 0.5000000000000000 0.5000000000000000 0.5000000000000000 Sn4 + 0.0000000000000000 0.0000000000000000 0.0000000000000000 Sn4 + 0.8059722950000000 0.1940277050000000 0.5000000000000000 O2 - 0.1940277050000000 0.8059722950000000 0.5000000000000000 O2 - 0.3059722950000000 0.3059722950000001 0.0000000000000000 O2 - 0.6940277050000000 0.6940277050000000 0.0000000000000000 O2 - The unit vector in real and reciprocal space are defined as: \\[ \\begin{equation} \\begin{aligned} \\mathbf{a}_1&=(a,0,0),\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\,\\quad\\quad\\quad\\quad \\mathbf{b}_1=\\frac{2\\pi}{V}\\mathbf{a}_2\\times\\mathbf{a}_3\\\\ \\mathbf{a}_2&=(b\\cos\\gamma,b\\sin\\gamma,0),\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\quad\\quad\\quad\\quad\\mathbf{b}_2=\\frac{2\\pi}{V}\\mathbf{a}_3\\times\\mathbf{a}_1\\\\ \\mathbf{a}_3&=(c\\cos\\beta,cn_2,c\\sqrt{\\sin^2\\beta+n_2^2}),\\quad\\quad\\quad\\quad\\quad\\quad\\mathbf{b}_3=\\frac{2\\pi}{V}\\mathbf{a}_1\\times\\mathbf{a}_2 \\end{aligned} \\end{equation} \\] where \\((a,b,c)\\) and \\((\\alpha,\\beta,\\gamma)\\) are lattice constants and angles of unit cell, \\[ \\begin{equation} n_2=\\frac{\\cos\\alpha-\\cos\\beta\\cos\\gamma}{\\sin\\gamma} \\end{equation} \\] \\[ \\begin{equation} V= \\mathbf{a}_1\\cdot(\\mathbf{a}_2\\times\\mathbf{a}_3) \\end{equation} \\] We also made a rotation matrix to help adjust the sample orientation if the it is not ideally given by in the crystal structure file: \\[ \\begin{equation} M=\\left(\\begin{array}{ccc} \\mathbf{a}_1\\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{array}\\right)=\\left(\\begin{array}{ccc} a & 0 & 0\\\\ b\\cos\\gamma & b\\sin\\gamma & 0 \\\\ c\\cos\\beta & c n_2 & c\\sqrt{\\sin^2\\beta+n_2^2} \\end{array}\\right) \\end{equation} \\] \\[ \\begin{equation} \\hat{q},\\,|\\mathbf{q}|,\\,\\Delta E \\end{equation} \\] \\[ \\begin{equation} E=\\sqrt{m^2c^4+p^2c^2} \\end{equation} \\] \\[ \\begin{equation} R_x(\\theta)=\\left(\\begin{array}{ccc} 1 & 0 & 0\\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{array}\\right),\\quad R_y(\\theta)=\\left(\\begin{array}{ccc} \\cos\\theta & 0 & -\\sin\\theta\\\\ 0 & 1 & 0 \\\\ \\sin\\theta & 0 & \\cos\\theta \\end{array}\\right) \\end{equation} \\] Multiply Matrix M by \\(R_x(\\theta)\\) or \\(R_y(\\theta)\\) gives the rotated lattice vectors. Position of Bragg peaks with Miller index (hkl): \\[ \\begin{equation} \\mathbf{G}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Intensity Input2 --> Intensity Input2: Input Input2: Peak Broadening parameters Input2: 2D image grid Intensity --> 2d 2d: 2d image display Download the source code. Code Set the parameters Read CIF Simulation Plot import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects # use thetax and thetay to adjust initial orientation of the sample thetax = np . pi / 2 * 1 thetay = np . pi / 2 * 0 hkl_dimension = 10 # sigma_theta, if you need a small number for single crystal, input~0.01, # if you need infinity, input~1000 sigma1 = 0.02 # sigma_phi sigma2 = 1000 # sigma_r, use this to tune the peak linewidth sigma3 = 0.01 # settings for imagine plane resolutionx = 300 qxymax = 2.5 qzmax = 3 qzmin = 0 resolutionz = int ( resolutionx / qxymax * qzmax ) gridx , gridz = np . meshgrid ( np . linspace ( - qxymax , qxymax , resolutionx ), np . linspace ( qzmin , qzmax , resolutionz )) # read crystal structure from POSCAR # POSCAR file which can be easily converted from cif on VESTA (fractional coordinate) dirr = '' filename = 'MA2DMF2Pb3I8_Petrov2017' address = dirr + filename + '.vasp' a1 , a2 , a3 , positions = diff . read_poscar ( address ) # example (graphite) Bpeaks , Mqxy , Mqz , I_miller = diff . Braggg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) t1_start = time . process_time () # calculated GIWAXS pattern III = diff . intensity ( gridx , gridz , Bpeaks , sigma1 , sigma2 , sigma3 , hkl_dimension ) t1_stop = time . process_time () print ( 'cpu time =' ) print ( t1_stop - t1_start , 's' ) # make the plot colorbar = 0.5 # upper limit # II1=np.log(III+1) II1 = III fig , ax = plt . subplots ( figsize = ( 14 , 14 )) plt . imshow ( II1 , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = [ - qxymax , qxymax , qzmin , qzmax ], vmax = colorbar * II1 . max (), vmin = II1 . min ()) ax . set_xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) ax . set_ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) ax . set_title ( filename + ' GIWAXS simulation' , fontsize = 16 ) fig . set_size_inches ([ 17 , 10 ])","title":"GIWAXS Simulation"},{"location":"GIWAXS/GIWAXS%20Simulation/#giwaxs-simulation-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) A program for 2D material diffraction simulation is introduced in this work. The sample is considered as crystallites with a Gaussian distribution in orientation in spherical coordinate (r, \\(\\theta\\) , \\(\\phi\\) ). The simulated diffraction pattern is in (q \\(_x\\) , q \\(_{xy}\\) ) plane which is designed to compare with WAXS(wide angle x-ray scattering) measurement. Thus Braggg peaks elongates in a ring pattern from their original positions in reciprocal space. Fig 1. (a) Crystal structure of 2D perovskite; (b) GIWAXS data of PPA; (c) GIWAXS simulation of PPA.","title":"GIWAXS Simulation tool in Python"},{"location":"GIWAXS/GIWAXS%20Simulation/#diffraction-intensity","text":"In reciprocal space, the Gaussian distribution in crystallites orientation results in a rotation for each Bragg peak. If we consider using an area detector to measure the diffraction intensity in q \\(_z\\) q \\(_{x}\\) plane. It is a summation of all Bragg peaks with each of them has the same Gaussian width( \\(\\sigma_\\theta\\) , \\(\\sigma_\\phi\\) ) centered in (q \\(_x\\) , q \\(_y\\) , q \\(_z\\) ): \\[ \\begin{equation} I(q_z,q_{x})=\\sum_{h,k,l}|\\sum_{i} f_i(\\mathbf{Q}) e^{i\\mathbf{Q}\\cdot\\mathbf{r}_n}|^2 e^{-\\frac{1}{2}\\frac{(\\theta^I-\\theta_0^B)^2}{\\sigma_\\theta^2}}e^{-\\frac{1}{2}\\frac{(\\phi^I-\\phi_0^B)^2}{\\sigma_\\phi^2}}e^{-\\frac{1}{2}\\frac{(q^I-q_0^B)^2}{\\sigma_q^2}} \\end{equation} \\] where ( \\(q^I\\) , \\(\\theta^I\\) , \\(\\phi^I\\) ) is the position of image plane(q \\(_x\\) , q \\(_z\\) ) in spherical coordinate. Fig 2. Spherical Coordinate \\[ \\begin{equation} q=\\sqrt{q_z^2+q_{x}^2},\\quad \\theta=\\frac{\\pi}{2}-\\arctan\\frac{q_z}{|q_{x}|}, \\quad \\phi= \\left\\{ \\begin{array}{cc} 0, \\quad x>0\\\\ \\pi,\\quad x<0 \\end{array} \\right. \\end{equation} \\] \\(\\mathbf{Q}\\) is the position of Bragg peaks and (hkl) is Miller index. \\(n\\) indicate the atoms in the unit cell and r \\(_n\\) is the real space position of \\(n\\) th atom in the unit cell. \\[ \\begin{equation} \\mathbf{Q}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] ( \\(q_0^B\\) , \\(\\theta_0^B\\) , \\(\\phi_0^B\\) ) is the position of Bragg peaks in reciprocal space converted to spherical coordinates: \\[ \\begin{equation} q_0^B=|\\mathbf{Q}|,\\quad\\theta_0^B=\\arctan\\frac{Q_z}{\\sqrt{Q_x^2+Q_y^2}},\\quad\\phi_0^B=\\arccos\\frac{Q_y}{\\sqrt{Q_x^2+Q_y^2}} \\end{equation} \\] It should be noticed that this is a theoretical result in (q \\(_z\\) ,q \\(_x\\) ) plane. Diffraction Ewald sphere is not considered here. Thus there is no 'missing wadge' as it always appears in GIWAXS. And a Gaussion profile in \\(\\hat{q}\\) direction is added to make a finite peak width in 2D image plane. In real materials the line shape in \\(\\hat{q}\\) is Lorentizian which depends on strain and crystallite size.","title":"Diffraction Intensity"},{"location":"GIWAXS/GIWAXS%20Simulation/#bragg-peaks","text":"Although we aim at 2D material in this proposal, a 3D crystal structure is needed to calculate the Bragg peaks. If the position of atoms is described in 2D, we need to assume a lattice constant or d-spacing in z-direction. The single crystal Bragg peaks are calculated from crystal structure file(.cif, POSCAR et. al) where lattice parameters and the positions of atoms in real space are provided. POSCAR File Sn2 O4 1.0 4.7648180450000002 0.0000000000000000 0.0000000000000003 0.0000000000000008 4.7648180450000002 0.0000000000000003 0.0000000000000000 0.0000000000000000 3.2074997700000001 Sn O 2 4 direct 0.5000000000000000 0.5000000000000000 0.5000000000000000 Sn4 + 0.0000000000000000 0.0000000000000000 0.0000000000000000 Sn4 + 0.8059722950000000 0.1940277050000000 0.5000000000000000 O2 - 0.1940277050000000 0.8059722950000000 0.5000000000000000 O2 - 0.3059722950000000 0.3059722950000001 0.0000000000000000 O2 - 0.6940277050000000 0.6940277050000000 0.0000000000000000 O2 - The unit vector in real and reciprocal space are defined as: \\[ \\begin{equation} \\begin{aligned} \\mathbf{a}_1&=(a,0,0),\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\,\\quad\\quad\\quad\\quad \\mathbf{b}_1=\\frac{2\\pi}{V}\\mathbf{a}_2\\times\\mathbf{a}_3\\\\ \\mathbf{a}_2&=(b\\cos\\gamma,b\\sin\\gamma,0),\\quad\\quad\\quad\\quad\\quad\\quad\\,\\,\\,\\quad\\quad\\quad\\quad\\mathbf{b}_2=\\frac{2\\pi}{V}\\mathbf{a}_3\\times\\mathbf{a}_1\\\\ \\mathbf{a}_3&=(c\\cos\\beta,cn_2,c\\sqrt{\\sin^2\\beta+n_2^2}),\\quad\\quad\\quad\\quad\\quad\\quad\\mathbf{b}_3=\\frac{2\\pi}{V}\\mathbf{a}_1\\times\\mathbf{a}_2 \\end{aligned} \\end{equation} \\] where \\((a,b,c)\\) and \\((\\alpha,\\beta,\\gamma)\\) are lattice constants and angles of unit cell, \\[ \\begin{equation} n_2=\\frac{\\cos\\alpha-\\cos\\beta\\cos\\gamma}{\\sin\\gamma} \\end{equation} \\] \\[ \\begin{equation} V= \\mathbf{a}_1\\cdot(\\mathbf{a}_2\\times\\mathbf{a}_3) \\end{equation} \\] We also made a rotation matrix to help adjust the sample orientation if the it is not ideally given by in the crystal structure file: \\[ \\begin{equation} M=\\left(\\begin{array}{ccc} \\mathbf{a}_1\\\\ \\mathbf{a}_2 \\\\ \\mathbf{a}_3 \\end{array}\\right)=\\left(\\begin{array}{ccc} a & 0 & 0\\\\ b\\cos\\gamma & b\\sin\\gamma & 0 \\\\ c\\cos\\beta & c n_2 & c\\sqrt{\\sin^2\\beta+n_2^2} \\end{array}\\right) \\end{equation} \\] \\[ \\begin{equation} \\hat{q},\\,|\\mathbf{q}|,\\,\\Delta E \\end{equation} \\] \\[ \\begin{equation} E=\\sqrt{m^2c^4+p^2c^2} \\end{equation} \\] \\[ \\begin{equation} R_x(\\theta)=\\left(\\begin{array}{ccc} 1 & 0 & 0\\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{array}\\right),\\quad R_y(\\theta)=\\left(\\begin{array}{ccc} \\cos\\theta & 0 & -\\sin\\theta\\\\ 0 & 1 & 0 \\\\ \\sin\\theta & 0 & \\cos\\theta \\end{array}\\right) \\end{equation} \\] Multiply Matrix M by \\(R_x(\\theta)\\) or \\(R_y(\\theta)\\) gives the rotated lattice vectors. Position of Bragg peaks with Miller index (hkl): \\[ \\begin{equation} \\mathbf{G}=h\\mathbf{b}_1+k\\mathbf{b}_2+l\\mathbf{b}_3 \\end{equation} \\] Workflow of this program: stateDiagram-v2 CIF --> POSCAR POSCAR: POSCAR POSCAR: Lattice Constants POSCAR: Atom position POSCAR --> Bragg Input1 --> Bragg Input1: Input Input1: (hkl) dimensions Input1: Rotation Bragg: Bragg peak Bragg: Bragg peak postitions in reciprocal space (3D) Bragg --> Intensity Input2 --> Intensity Input2: Input Input2: Peak Broadening parameters Input2: 2D image grid Intensity --> 2d 2d: 2d image display Download the source code. Code Set the parameters Read CIF Simulation Plot import numpy as np import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import scipy.ndimage as ndimage import matplotlib.patheffects as path_effects # use thetax and thetay to adjust initial orientation of the sample thetax = np . pi / 2 * 1 thetay = np . pi / 2 * 0 hkl_dimension = 10 # sigma_theta, if you need a small number for single crystal, input~0.01, # if you need infinity, input~1000 sigma1 = 0.02 # sigma_phi sigma2 = 1000 # sigma_r, use this to tune the peak linewidth sigma3 = 0.01 # settings for imagine plane resolutionx = 300 qxymax = 2.5 qzmax = 3 qzmin = 0 resolutionz = int ( resolutionx / qxymax * qzmax ) gridx , gridz = np . meshgrid ( np . linspace ( - qxymax , qxymax , resolutionx ), np . linspace ( qzmin , qzmax , resolutionz )) # read crystal structure from POSCAR # POSCAR file which can be easily converted from cif on VESTA (fractional coordinate) dirr = '' filename = 'MA2DMF2Pb3I8_Petrov2017' address = dirr + filename + '.vasp' a1 , a2 , a3 , positions = diff . read_poscar ( address ) # example (graphite) Bpeaks , Mqxy , Mqz , I_miller = diff . Braggg_peaks ( a1 , a2 , a3 , positions , thetax , thetay , hkl_dimension ) t1_start = time . process_time () # calculated GIWAXS pattern III = diff . intensity ( gridx , gridz , Bpeaks , sigma1 , sigma2 , sigma3 , hkl_dimension ) t1_stop = time . process_time () print ( 'cpu time =' ) print ( t1_stop - t1_start , 's' ) # make the plot colorbar = 0.5 # upper limit # II1=np.log(III+1) II1 = III fig , ax = plt . subplots ( figsize = ( 14 , 14 )) plt . imshow ( II1 , interpolation = 'nearest' , cmap = cm . jet , origin = 'lower' , extent = [ - qxymax , qxymax , qzmin , qzmax ], vmax = colorbar * II1 . max (), vmin = II1 . min ()) ax . set_xlabel ( 'q$_ {xy} $(1/A)' , fontsize = 16 ) ax . set_ylabel ( 'q$_ {z} $(1/A)' , fontsize = 16 ) ax . set_title ( filename + ' GIWAXS simulation' , fontsize = 16 ) fig . set_size_inches ([ 17 , 10 ])","title":"Bragg Peaks"},{"location":"GIWAXS/GIWAXS%20image%20tool/","text":"GIWAXS image tool in Python \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) This is an example of the GIWAXS class in python. Import libraries, the GIWAXS class is included in GIWAXS.py. Code import numpy as np import pandas as pd import math import matplotlib.pyplot as plt import matplotlib.cm as cm import scipy.io from scipy.optimize import curve_fit import GIWAXS import scipy.misc import os from PIL import Image import tifffile Load experiment data (.tiff file) with the coordinate. And create a GIWAXS object by M=GIWAXS.GIWAXS(...). Code Output # read .tiff file dirr = \"\" filename = \"test_qmap\" path = os . path . join ( dirr , filename ) f = tifffile . imread ( path + '.tiff' ) Giwaxs_data = np . array ( f ) qzmax = np . max ( np . loadtxt ( 'test_qz.txt' )) / 10 qzmin = np . min ( np . loadtxt ( 'test_qz.txt' )) / 10 qxymax = np . max ( np . loadtxt ( 'test_qxy.txt' )) / 10 qxymin = np . min ( np . loadtxt ( 'test_qxy.txt' )) / 10 qz = [ qzmin , qzmax ] qxy = [ qxymin , qxymax ] M = GIWAXS . GIWAXS ( Giwaxs_data , qxy , qz , 'Example' , dirr ) M . switch_qxy () M . switch_qz () M . imshow () print ( 'qz=' , qz ) print ( 'qxy=' , qxy ) qz= -1.8346400457410241 2.8658707336457097 qxy= -2.4817527502473498 2.10232264951378 Then you can use cut() function to resize your GIWAXS image. Code Output M . cut ([ 0 , 2 ],[ 0 , 2 ]) M . rename ( 'image cut example' ) M . cut_imshow () peak_finder() can help you find the peaks in the cut image. Tune neighborhood_size and threshold to improve the performance. You can also print (q \\(_{xy}\\) , q \\(_z\\) ) and q by setting print_peak_position to True Code Output neighborhood_size = 30 threshold = 30 print_peak_position = True colorbar = 0.1 M . cut_imshow () M . peak_finder ( neighborhood_size , threshold , print_peak_position ) Qzint() integrate the selected area and gives the intensity vs q \\(_z\\) . Qxyint() gives intensity vs q \\(_{xy}\\) . Code Output qxy1 = [ 0.3 , 0.4 ] qz1 = [ 0.2 , 0.4 ] M . rename ( 'qzint example' ) M . qzint ( qxy1 , qz1 ) M . qzint_imshow () aglint() integrate the selected sector to get intensity vs q. qp defines the number of points in \\(q\\) . A smooth option is also offered to convolute the curve. Code Output angle = [ - 40 , - 25 ] qrange = [ 0.6 , 0.77 ] smooth1 = False qp = 20 M . aglint ( angle , qrange , qp , smooth = smooth1 , Nsmooth = 10 ) q0 , I0 = M . aglint_imshow ()","title":"GIWAXS image tool"},{"location":"GIWAXS/GIWAXS%20image%20tool/#giwaxs-image-tool-in-python","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) This is an example of the GIWAXS class in python. Import libraries, the GIWAXS class is included in GIWAXS.py. Code import numpy as np import pandas as pd import math import matplotlib.pyplot as plt import matplotlib.cm as cm import scipy.io from scipy.optimize import curve_fit import GIWAXS import scipy.misc import os from PIL import Image import tifffile Load experiment data (.tiff file) with the coordinate. And create a GIWAXS object by M=GIWAXS.GIWAXS(...). Code Output # read .tiff file dirr = \"\" filename = \"test_qmap\" path = os . path . join ( dirr , filename ) f = tifffile . imread ( path + '.tiff' ) Giwaxs_data = np . array ( f ) qzmax = np . max ( np . loadtxt ( 'test_qz.txt' )) / 10 qzmin = np . min ( np . loadtxt ( 'test_qz.txt' )) / 10 qxymax = np . max ( np . loadtxt ( 'test_qxy.txt' )) / 10 qxymin = np . min ( np . loadtxt ( 'test_qxy.txt' )) / 10 qz = [ qzmin , qzmax ] qxy = [ qxymin , qxymax ] M = GIWAXS . GIWAXS ( Giwaxs_data , qxy , qz , 'Example' , dirr ) M . switch_qxy () M . switch_qz () M . imshow () print ( 'qz=' , qz ) print ( 'qxy=' , qxy ) qz= -1.8346400457410241 2.8658707336457097 qxy= -2.4817527502473498 2.10232264951378 Then you can use cut() function to resize your GIWAXS image. Code Output M . cut ([ 0 , 2 ],[ 0 , 2 ]) M . rename ( 'image cut example' ) M . cut_imshow () peak_finder() can help you find the peaks in the cut image. Tune neighborhood_size and threshold to improve the performance. You can also print (q \\(_{xy}\\) , q \\(_z\\) ) and q by setting print_peak_position to True Code Output neighborhood_size = 30 threshold = 30 print_peak_position = True colorbar = 0.1 M . cut_imshow () M . peak_finder ( neighborhood_size , threshold , print_peak_position ) Qzint() integrate the selected area and gives the intensity vs q \\(_z\\) . Qxyint() gives intensity vs q \\(_{xy}\\) . Code Output qxy1 = [ 0.3 , 0.4 ] qz1 = [ 0.2 , 0.4 ] M . rename ( 'qzint example' ) M . qzint ( qxy1 , qz1 ) M . qzint_imshow () aglint() integrate the selected sector to get intensity vs q. qp defines the number of points in \\(q\\) . A smooth option is also offered to convolute the curve. Code Output angle = [ - 40 , - 25 ] qrange = [ 0.6 , 0.77 ] smooth1 = False qp = 20 M . aglint ( angle , qrange , qp , smooth = smooth1 , Nsmooth = 10 ) q0 , I0 = M . aglint_imshow ()","title":"GIWAXS image tool in Python"},{"location":"GIWAXS/GIWAXS%20reverse%20problem/","text":"GIWAXS reverse problem \u00b6 Zihan Zhang ( zihan.zhang-1@colorado.edu ) Reversed GIWAXS problem: derive the lattice parameters from the given GIWAXS pattern. A brute-force search program Blue print of the program \u00b6 GIWAXS reverse problem Input Given peak positions (In the first quadrant only) A guess of \\(\\vec{G}\\) DOF analysis Original 9 degrees of freedom [ \\(a^*_x\\) , \\(a^*_y\\) , \\(a^*_z\\) ] [ \\(b^*_x\\) , \\(b^*_y\\) , \\(b^*_z\\) ] [ \\(c^*_x\\) , \\(c^*_y\\) , \\(c^*_z\\) ] Force \\(\\vec{a}^*\\) to be in [ \\(a_x^*\\) ,0, \\(a_z^*\\) ] direction (kills 1 degrees of freedom (DOF=8)) Find the peak that is nearest to [0,0,0] (gives \\(a_x^*\\) and \\(a_z^*\\) , (DOF=6)) Remove peaks \\(\\vec{a}^*\\) , \\(2\\vec{a}^*\\) , \\(3\\vec{a}^*\\) , ... Find the next nearest peak (gives [ \\(b_{xy}^*\\) , \\(b_z^*\\) ] and kills 2 DOF (DOF=4)) Algorithm Monte Carlo (good for high dimensions), Markov chain (Brute-force search. This is a ill-conditioned problem with a lot of local minimums.) Cost function: add up the distance of each given peak to the nearest simulated peak. add up the distance of each simulated peak to the nearest given peak. (make sure every peak find their friend) Optimization use gradient decent after MT to boost the convergence convert the output lattice parameter to a high symmetry format Import libraries Code import numpy as np import scipy.ndimage as ndimage import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import matplotlib.patheffects as path_effects Input Code Functions qxy_exp = [ 0 , 4 ] qz_exp = [ 0 , 4 ] Bragg_peaks_exp = [ [ 0 , 1 ], [ 0 , 2 ], [ 0 , 3 ], [ 2 , 0 ], [ 2 , 1 ], [ 2 , 2 ], [ 2 , 3 ], [ 2.818 , 0 ], [ 2.818 , 1 ], [ 2.818 , 2 ], [ 2.818 , 3 ], [ 1.414 , 0.5 ], [ 1.414 , 1.5 ], [ 1.414 , 2.5 ], [ 3.16 , 0.5 ], [ 3.16 , 1.5 ], [ 3.16 , 2.5 ], [ 4.24 , 0.5 ], [ 4.24 , 1.5 ], [ 4.24 , 2.5 ], [ 4 , 0 ], [ 4 , 1 ], [ 4 , 2 ], [ 4 , 3 ] ] hkl = 5 def make_cif ( Bragg_peaks ): # b1=[np.random.uniform(-ub, ub),0,np.random.uniform(-ub, ub)] b2x = np . random . uniform ( - 1.5 , 1.5 ) b3x = np . random . uniform ( - 5 , 5 ) b3y = np . random . uniform ( - 5 , 5 ) b3z = np . random . uniform ( - 5 , 5 ) b1 = [ 0 , 0 , 1 ] b2 = [ b2x , np . sqrt ( 2.25 - b2x * b2x ), 0.5 ] b3 = [ b3x , b3y , b3z ] return b1 , b2 , b3 def find_c ( array ): x_values_with_leading_zero = [ pair [ 1 ] for pair in array if pair [ 0 ] == 0 ] if not x_values_with_leading_zero : return None return min ( x_values_with_leading_zero ) def closest_distance ( array , point ): # Convert the input to numpy arrays if they aren't already array = np . array ( array ) point = np . array ( point ) # Compute squared distances squared_distances = np . sum (( array - point ) ** 2 , axis = 1 ) # Find the minimum squared distance and take its square root to get the actual distance min_distance = np . sqrt ( np . min ( squared_distances )) return min_distance def Bragg_peaks ( b1 , b2 , b3 , hkl_dimension ): # grid for Miller index i = np . linspace ( - hkl_dimension , hkl_dimension , 2 * hkl_dimension + 1 ) H , K , L = np . meshgrid ( i , i , i ) # The position of Bragg peaks in reciprocal space G1 = H * b1 [ 0 ] + K * b2 [ 0 ] + L * b3 [ 0 ] G2 = H * b1 [ 1 ] + K * b2 [ 1 ] + L * b3 [ 1 ] G3 = H * b1 [ 2 ] + K * b2 [ 2 ] + L * b3 [ 2 ] q2 = G1 * G1 + G2 * G2 + G3 * G3 F = 1 Bpeaks = np . concatenate (( G1 , G2 , G3 ), axis = 0 ) # return Bpeaks,pow(G1*G1+G2*G2,0.5),pow(G3*G3,0.5) return pow ( G1 * G1 + G2 * G2 , 0.5 ), pow ( G3 * G3 , 0.5 ) def FT ( a1 , a2 , a3 ): # Lattice parameters M matrix in cartesian coordinate(angstrom) M = [ a1 , a2 , a3 ] M = np . asarray ( M ) # New lattice parameter aa1 = M [ 0 ,:] aa2 = M [ 1 ,:] aa3 = M [ 2 ,:] # reciprocal lattice volume = np . matmul ( aa3 , np . cross ( aa1 , aa2 )) b1 = 2 * np . pi * np . cross ( aa2 , aa3 ) / volume b2 = 2 * np . pi * np . cross ( aa3 , aa1 ) / volume b3 = 2 * np . pi * np . cross ( aa1 , aa2 ) / volume print ( b1 , b2 , b3 ) Main Code total_distance0 = 99999999 for i in range ( 500000 ): b1 , b2 , b3 = make_cif ( Bragg_peaks_exp ) qxy , qz = Bragg_peaks ( b1 , b2 , b3 , hkl ) qxy = qxy . ravel () qz = qz . ravel () combined = np . column_stack (( qxy , qz )) j = 0 total_distance = 0 for ii in Bragg_peaks_exp : total_distance = total_distance + closest_distance ( combined , Bragg_peaks_exp [ j ]) j = j + 1 j1 = 0 for ii in combined : if combined [ j1 , 0 ] < qxy_exp [ 1 ]: if combined [ j1 , 1 ] < qz_exp [ 1 ]: total_distance = total_distance + closest_distance ( Bragg_peaks_exp , combined [ j1 ]) j1 = j1 + 1 if total_distance < total_distance0 : total_distance0 = total_distance FT ( b1 , b2 , b3 ) Performance: The result from a test on PC. (~ 25 miniutes cpu time) Lattice parameter [ 1.09233506 - 2.95321592 6.28318531 ] [ - 2.18850426 5.89804628 0. ] [ - 1.84097256 - 4.0263532 0. ] ## rotate this lattice and re-define lattice parameters to make it symmetric, you'll get a = [ - pi , pi , 0 ] b = [ - pi , - pi , 0 ] c = [ pi , 0 , 2 pi ] Fig 1. (a) The reverse problem (b) Simulation using the lattice parameter found by the program.","title":"GIWAXS reverse problem"},{"location":"GIWAXS/GIWAXS%20reverse%20problem/#giwaxs-reverse-problem","text":"Zihan Zhang ( zihan.zhang-1@colorado.edu ) Reversed GIWAXS problem: derive the lattice parameters from the given GIWAXS pattern. A brute-force search program","title":"GIWAXS reverse problem"},{"location":"GIWAXS/GIWAXS%20reverse%20problem/#blue-print-of-the-program","text":"GIWAXS reverse problem Input Given peak positions (In the first quadrant only) A guess of \\(\\vec{G}\\) DOF analysis Original 9 degrees of freedom [ \\(a^*_x\\) , \\(a^*_y\\) , \\(a^*_z\\) ] [ \\(b^*_x\\) , \\(b^*_y\\) , \\(b^*_z\\) ] [ \\(c^*_x\\) , \\(c^*_y\\) , \\(c^*_z\\) ] Force \\(\\vec{a}^*\\) to be in [ \\(a_x^*\\) ,0, \\(a_z^*\\) ] direction (kills 1 degrees of freedom (DOF=8)) Find the peak that is nearest to [0,0,0] (gives \\(a_x^*\\) and \\(a_z^*\\) , (DOF=6)) Remove peaks \\(\\vec{a}^*\\) , \\(2\\vec{a}^*\\) , \\(3\\vec{a}^*\\) , ... Find the next nearest peak (gives [ \\(b_{xy}^*\\) , \\(b_z^*\\) ] and kills 2 DOF (DOF=4)) Algorithm Monte Carlo (good for high dimensions), Markov chain (Brute-force search. This is a ill-conditioned problem with a lot of local minimums.) Cost function: add up the distance of each given peak to the nearest simulated peak. add up the distance of each simulated peak to the nearest given peak. (make sure every peak find their friend) Optimization use gradient decent after MT to boost the convergence convert the output lattice parameter to a high symmetry format Import libraries Code import numpy as np import scipy.ndimage as ndimage import diffraction as diff import matplotlib.pyplot as plt import matplotlib.cm as cm import time as time from matplotlib.widgets import Button import scipy.io from matplotlib.widgets import RangeSlider import matplotlib.patheffects as path_effects Input Code Functions qxy_exp = [ 0 , 4 ] qz_exp = [ 0 , 4 ] Bragg_peaks_exp = [ [ 0 , 1 ], [ 0 , 2 ], [ 0 , 3 ], [ 2 , 0 ], [ 2 , 1 ], [ 2 , 2 ], [ 2 , 3 ], [ 2.818 , 0 ], [ 2.818 , 1 ], [ 2.818 , 2 ], [ 2.818 , 3 ], [ 1.414 , 0.5 ], [ 1.414 , 1.5 ], [ 1.414 , 2.5 ], [ 3.16 , 0.5 ], [ 3.16 , 1.5 ], [ 3.16 , 2.5 ], [ 4.24 , 0.5 ], [ 4.24 , 1.5 ], [ 4.24 , 2.5 ], [ 4 , 0 ], [ 4 , 1 ], [ 4 , 2 ], [ 4 , 3 ] ] hkl = 5 def make_cif ( Bragg_peaks ): # b1=[np.random.uniform(-ub, ub),0,np.random.uniform(-ub, ub)] b2x = np . random . uniform ( - 1.5 , 1.5 ) b3x = np . random . uniform ( - 5 , 5 ) b3y = np . random . uniform ( - 5 , 5 ) b3z = np . random . uniform ( - 5 , 5 ) b1 = [ 0 , 0 , 1 ] b2 = [ b2x , np . sqrt ( 2.25 - b2x * b2x ), 0.5 ] b3 = [ b3x , b3y , b3z ] return b1 , b2 , b3 def find_c ( array ): x_values_with_leading_zero = [ pair [ 1 ] for pair in array if pair [ 0 ] == 0 ] if not x_values_with_leading_zero : return None return min ( x_values_with_leading_zero ) def closest_distance ( array , point ): # Convert the input to numpy arrays if they aren't already array = np . array ( array ) point = np . array ( point ) # Compute squared distances squared_distances = np . sum (( array - point ) ** 2 , axis = 1 ) # Find the minimum squared distance and take its square root to get the actual distance min_distance = np . sqrt ( np . min ( squared_distances )) return min_distance def Bragg_peaks ( b1 , b2 , b3 , hkl_dimension ): # grid for Miller index i = np . linspace ( - hkl_dimension , hkl_dimension , 2 * hkl_dimension + 1 ) H , K , L = np . meshgrid ( i , i , i ) # The position of Bragg peaks in reciprocal space G1 = H * b1 [ 0 ] + K * b2 [ 0 ] + L * b3 [ 0 ] G2 = H * b1 [ 1 ] + K * b2 [ 1 ] + L * b3 [ 1 ] G3 = H * b1 [ 2 ] + K * b2 [ 2 ] + L * b3 [ 2 ] q2 = G1 * G1 + G2 * G2 + G3 * G3 F = 1 Bpeaks = np . concatenate (( G1 , G2 , G3 ), axis = 0 ) # return Bpeaks,pow(G1*G1+G2*G2,0.5),pow(G3*G3,0.5) return pow ( G1 * G1 + G2 * G2 , 0.5 ), pow ( G3 * G3 , 0.5 ) def FT ( a1 , a2 , a3 ): # Lattice parameters M matrix in cartesian coordinate(angstrom) M = [ a1 , a2 , a3 ] M = np . asarray ( M ) # New lattice parameter aa1 = M [ 0 ,:] aa2 = M [ 1 ,:] aa3 = M [ 2 ,:] # reciprocal lattice volume = np . matmul ( aa3 , np . cross ( aa1 , aa2 )) b1 = 2 * np . pi * np . cross ( aa2 , aa3 ) / volume b2 = 2 * np . pi * np . cross ( aa3 , aa1 ) / volume b3 = 2 * np . pi * np . cross ( aa1 , aa2 ) / volume print ( b1 , b2 , b3 ) Main Code total_distance0 = 99999999 for i in range ( 500000 ): b1 , b2 , b3 = make_cif ( Bragg_peaks_exp ) qxy , qz = Bragg_peaks ( b1 , b2 , b3 , hkl ) qxy = qxy . ravel () qz = qz . ravel () combined = np . column_stack (( qxy , qz )) j = 0 total_distance = 0 for ii in Bragg_peaks_exp : total_distance = total_distance + closest_distance ( combined , Bragg_peaks_exp [ j ]) j = j + 1 j1 = 0 for ii in combined : if combined [ j1 , 0 ] < qxy_exp [ 1 ]: if combined [ j1 , 1 ] < qz_exp [ 1 ]: total_distance = total_distance + closest_distance ( Bragg_peaks_exp , combined [ j1 ]) j1 = j1 + 1 if total_distance < total_distance0 : total_distance0 = total_distance FT ( b1 , b2 , b3 ) Performance: The result from a test on PC. (~ 25 miniutes cpu time) Lattice parameter [ 1.09233506 - 2.95321592 6.28318531 ] [ - 2.18850426 5.89804628 0. ] [ - 1.84097256 - 4.0263532 0. ] ## rotate this lattice and re-define lattice parameters to make it symmetric, you'll get a = [ - pi , pi , 0 ] b = [ - pi , - pi , 0 ] c = [ pi , 0 , 2 pi ] Fig 1. (a) The reverse problem (b) Simulation using the lattice parameter found by the program.","title":"Blue print of the program"},{"location":"GIWAXS/GIWAXS/","text":"GIWAXS experiment \u00b6","title":"GIWAXS experiment"},{"location":"GIWAXS/GIWAXS/#giwaxs-experiment","text":"","title":"GIWAXS experiment"},{"location":"GIWAXS/cc/","text":"Intro \u00b6 GIWAXS data analysis has 5 steps in general: GIWAXS data analysis Calibration Data reduction 2D image generation Area integration Peak fitting More advanced data analysis includes: Peak search GIWAXS pattern simulation Phase identification ... Calibration \u00b6 Calibration is a method to determine the sample-detector distance and the relative detector postion. A material (thin film, plate, or powders on a flat surface) with known lattice parameter is measured at high incident angles (<2 degrees). The collected 2D image from the calibration material is used to derive the detector position. The quantitative calculation can be done using a python package 'pyFAI'. pyFAI is written in python2, so the installation is complicate. Here is a guide for pyFAI installation: pyFAI installation Do not install pyFAI on your PC. Use NSLS-II jupyterhub if you have the access. Most of the packages you will need for GIWAXS data analysis is installed there. Use SMI_analysis package. This is a more advanced GIWAXS analysis package developed by beamline scientist at NSLS-II SMI beamline. pyFAI is included in SMI_analysis package. Use pyWAXS package developed by Toney Group. You will need to be added to ToneyGroup on Github to get access. (Recommanded) Directly install pyFAI on your PC. Good luck! If you have successfully installed any of the package above, you can start to do the calibration calculation. In the terminal, type: Command conda activate smi_analysis (or pyWAXS) pyfai-calib2 The pyFAI calibration UI will be opened: You will need to input: Parameters Detector Caliration materal X-ray energy 2d image for calibration (.tif) to do the calibration calculation. The .poni file will be generated for the use in the next step (data reduction). Data reduction \u00b6 The data reduction process convert the 2d detector image to the scattering instensity in the reciprocal space (qxy vs qz). This conversion considers the Ewald sphere correction with the experiment geometry. A missing wedge will appear after this step (if you use a grazing incident geometry). A simple data reduction code is below: Import Function Figure Output import numpy as np import os import pyFAI , fabio import matplotlib.pyplot as plt import matplotlib as mpl import pygix # from pylab import * import scipy.io as sio import scipy.integrate as integrate import image # %matplotlib inline print ( \"Using pyFAI version\" , pyFAI . version ) def pygix_reduction ( dirr , filename , poni_dirr , poni_filename , orientation , incident_angle ): path_poni = os . path . join ( poni_dirr , poni_filename ) pg = pygix . Transform () pg . load ( path_poni ) pg . sample_orientation = orientation pg . incident_angle = incident_angle pg . tilt_angle = 0 path = os . path . join ( dirr , filename ) data = fabio . open ( path ) . data ii_reciprocal , qxy , qz = pg . transform_reciprocal ( data , method = \"bbox\" , unit = \"nm\" ) return ii_reciprocal , qxy , qz dirr = \"temp\" filename = \"DD_S9_12110220_0001.tif\" poni_dirr = \"temp\" poni_filename = \"Demi.poni\" orientation = 3 incident_angle = 3 ii_reciprocal , qxy , qz = pygix_reduction ( dirr , filename , poni_dirr , poni_filename , orientation , incident_angle ) # show reduced image ii1 = np . array ( ii_reciprocal ) plt . imshow ( ii1 , extent = ( np . min ( qxy ) / 10 , np . max ( qxy ) / 10 , np . min ( qz ) / 10 , np . max ( qz ) / 10 ), origin = \"lower\" ) # plt.xlabel('q$_{xy}$ (1/A)') # plt.ylabel('q$_{z}$ (1/A)') plt . title ( 'DD_S9' ) # set color bar plt . set_cmap ( 'jet' ) lb = np . nanpercentile ( data , 10 ) ub = np . nanpercentile ( data , 90 ) plt . clim ( lb , ub ) Area integration \u00b6","title":"Crash course on GIWAXS data analysis"},{"location":"GIWAXS/cc/#intro","text":"GIWAXS data analysis has 5 steps in general: GIWAXS data analysis Calibration Data reduction 2D image generation Area integration Peak fitting More advanced data analysis includes: Peak search GIWAXS pattern simulation Phase identification ...","title":"Intro"},{"location":"GIWAXS/cc/#calibration","text":"Calibration is a method to determine the sample-detector distance and the relative detector postion. A material (thin film, plate, or powders on a flat surface) with known lattice parameter is measured at high incident angles (<2 degrees). The collected 2D image from the calibration material is used to derive the detector position. The quantitative calculation can be done using a python package 'pyFAI'. pyFAI is written in python2, so the installation is complicate. Here is a guide for pyFAI installation: pyFAI installation Do not install pyFAI on your PC. Use NSLS-II jupyterhub if you have the access. Most of the packages you will need for GIWAXS data analysis is installed there. Use SMI_analysis package. This is a more advanced GIWAXS analysis package developed by beamline scientist at NSLS-II SMI beamline. pyFAI is included in SMI_analysis package. Use pyWAXS package developed by Toney Group. You will need to be added to ToneyGroup on Github to get access. (Recommanded) Directly install pyFAI on your PC. Good luck! If you have successfully installed any of the package above, you can start to do the calibration calculation. In the terminal, type: Command conda activate smi_analysis (or pyWAXS) pyfai-calib2 The pyFAI calibration UI will be opened: You will need to input: Parameters Detector Caliration materal X-ray energy 2d image for calibration (.tif) to do the calibration calculation. The .poni file will be generated for the use in the next step (data reduction).","title":"Calibration"},{"location":"GIWAXS/cc/#data-reduction","text":"The data reduction process convert the 2d detector image to the scattering instensity in the reciprocal space (qxy vs qz). This conversion considers the Ewald sphere correction with the experiment geometry. A missing wedge will appear after this step (if you use a grazing incident geometry). A simple data reduction code is below: Import Function Figure Output import numpy as np import os import pyFAI , fabio import matplotlib.pyplot as plt import matplotlib as mpl import pygix # from pylab import * import scipy.io as sio import scipy.integrate as integrate import image # %matplotlib inline print ( \"Using pyFAI version\" , pyFAI . version ) def pygix_reduction ( dirr , filename , poni_dirr , poni_filename , orientation , incident_angle ): path_poni = os . path . join ( poni_dirr , poni_filename ) pg = pygix . Transform () pg . load ( path_poni ) pg . sample_orientation = orientation pg . incident_angle = incident_angle pg . tilt_angle = 0 path = os . path . join ( dirr , filename ) data = fabio . open ( path ) . data ii_reciprocal , qxy , qz = pg . transform_reciprocal ( data , method = \"bbox\" , unit = \"nm\" ) return ii_reciprocal , qxy , qz dirr = \"temp\" filename = \"DD_S9_12110220_0001.tif\" poni_dirr = \"temp\" poni_filename = \"Demi.poni\" orientation = 3 incident_angle = 3 ii_reciprocal , qxy , qz = pygix_reduction ( dirr , filename , poni_dirr , poni_filename , orientation , incident_angle ) # show reduced image ii1 = np . array ( ii_reciprocal ) plt . imshow ( ii1 , extent = ( np . min ( qxy ) / 10 , np . max ( qxy ) / 10 , np . min ( qz ) / 10 , np . max ( qz ) / 10 ), origin = \"lower\" ) # plt.xlabel('q$_{xy}$ (1/A)') # plt.ylabel('q$_{z}$ (1/A)') plt . title ( 'DD_S9' ) # set color bar plt . set_cmap ( 'jet' ) lb = np . nanpercentile ( data , 10 ) ub = np . nanpercentile ( data , 90 ) plt . clim ( lb , ub )","title":"Data reduction"},{"location":"GIWAXS/cc/#area-integration","text":"","title":"Area integration"},{"location":"GIWAXS/intro/","text":"Introduction to GIWAXS \u00b6","title":"Introduction to GIWAXS"},{"location":"GIWAXS/intro/#introduction-to-giwaxs","text":"","title":"Introduction to GIWAXS"},{"location":"GIWAXS/pyWAXS/","text":"pyWAXS \u00b6 pyWAXS: Our group's Python-based GIWAXS data reduction and analysis package. \u00b6 We intend for this module to include working UI (user interface) deployable executable(s) to assist with 2D GIWAXS data reduction, peak search & analysis, WAXS image simulation from (CIF/POSCAR) files, and reverse GIWAXS problem solving capabilities. Program Structure \u00b6 stateDiagram-v2 pyFAI --> Load pyFAI: (-zsh) pyFAI-calib2 pyFAI: - Create PONI Calibrant (.poni) pyFAI: - Create MASK (.edf) Load --> WAXSTransform Load: (jupyter) Load GIWAXS Data Load: - TIFF Datafile (.tiff) Load: - Mask (.edf, .json file) Load: - PONI Calibrant (.poni file) Parameters --> WAXSTransform Parameters: (jupyter) Input Parameters Parameters: - X-ray Energy (keV) Parameters: - Metadata Keys Parameters: - Incidence Angle (deg.) WAXSTransform: (class) WAXSTransform WAXSTransform: - Create Detector Object (PONI, MASK) WAXSTransform: - Apply Ewald Sphere Corrections WAXSTransform: - Perform pyFAI Image Caking WAXSTransform --> WAXSReduce WAXSReduce: (class) WAXSReduce WAXSReduce: - Store Image Data (Raw, Recip, Caked Data) WAXSReduce: - Image Processing/Corrections WAXSReduce: - Image Plotting WAXSReduce: - Export & Reload Processed Data (netCDF4) WAXSReduce --> WAXSSearch WAXSSearch: (class) WAXSSearch WAXSSearch: - 2D Peak Finder WAXSSearch --> WAXSPeakSelect WAXSPeakSelect: (UI) WAXSPeakSelect WAXSPeakSelect: - Manual Peak 'Cleaning' WAXSPeakSelect: - Peak Grouping WAXSPeakSelect --> WAXSReverse WAXSReverse --> WAXSAnalyze WAXSReverse: (class) WAXSReverse WAXSReverse: GIWAXS Reverse Solving Tool Parameters2: Input Parameters Parameters2: (jupyter) Input Parameters Parameters2: - Load CIF(s)/POSCAR Files Parameters2: - Select Initial Simulation Parameters Parameters2 --> WAXSDiffSim WAXSDiffSim: (class) WAXSDiffSim WAXSDiffSim: GIWAXS Simulation Tool WAXSDiffSim --> WAXSAnalyze WAXSAnalyze: (class) WAXSAnalyze WAXSAnalyze: Compare Simulated & Measured Bragg Peak Positions WAXSAnalyze --> Output Output: Output Output: - (Known Phases) Phase Orientation, Miller Indices, Crystallite Dispersity Output: - (Unknown Phases) Reciprocal Space Lattice Vectors, Miller Indices pyWAXS Development Task List \u00b6 Zihan 0. (Create Method) in WAXSReduce.py Subclass 'Integration1D(WAXSReduce)': Direct azimuthal integrator on reciprocal space map (no caking or pixel splitting). Integration will rely on data assignment for masked positions (NaN v. '0' v. '-1') - see Keith's 'Task 0'. 1. (Update Method) in WAXSReduce.py 'WAXSReduce' Class Method 'sinchi_corr': Review and update method 'sinchi_corr' used for sin(chi) correction. Check on usage and physical sample requirements for applying q^2 term. Check on application of sin(chi) correction factor in existing method. 2. (Algorithm Development/Update/Create Class Methods) in WAXSReverse.py 'WAXSReverse' Class: Create functional class methods for WAXSReverse brute force solver workflow to be implemented in a Jupyter notebook. Notebook user should be able to reloaded peak sets stored as netCDF4 (h5netcdf) files from WAXSPeakSelect.py UI exports (peak position, caked image, reciprocal space map xarray Datasets). See Keith task bullet points 1 & 2. 3. (Create Method) in WAXSReduce.py Class 'ImageInterpolator': Create a new Fourier transform class method for the image interpolation class that is presently saved in the WAXSReduce.py script. Keith 0. (Confirm Implementation): Check WAXSReduce Class methods, are mask regions being stored as '0', '-1', None, or NaN values in the DataArray/DataSets being stored as class attributes. 1. (Create Class Methods) in WAXSPeakSelect.py Classes: Create class methods to export a netCDF4 (h5netcdf) file from an active UI experiment session. User will be able to add/remove peaks from peak search outputs and export these peaks to a reloadable file format to the WAXSReverse.py 'WAXSReverse' Class. 2. (Create Class Methods) in WAXSReverse.py 'WAXSReverse' Class: Create a netCDF4 (h5netcdf) file loader for outputted Xarray DataSets to load sets of reduced data and paired peak positions from WAXSPeakSelect.py UI exports. 3. (Create Method) in WAXSPeakSelect.py MyCanvas(FigureCanvas) Class Method(s): Display Sliced ROI selection from DataArray for Integration1D(WAXSReduce) subclass method connections in UI. 4. (Update Documentation): (README) for local environment installation using Conda installation and mounted 'pyWAXS.yml' file. 5. (Add Documentation): Add a folder 'example' that contains example data/PONI/MASK/POSCAR files for data analysis. 6. (Update Method): Fix highlighting tool in WAXSPeakSelect.py UI, add (X) box. 7. (Create Method/Widget): Add an interactive table in WAXSPeakSelect.py UI to view selected/highlighted peaks in a group within a table. 8. (Create Method/Widget): Add buttons to 'Group' peaks in WAXSPeakSelect.py and select qxy, qz layer line binning in secondary table (later task). 9. (Create Method/Widget): Add method to load a CIF/POSCAR filepath as attribute into WAXSSim window. 10. (Update Methods): Update 'WAXSSim' class methods to work using Xarray Datasets, we will use sets of chunks to store our data. Each chunk will contain: (1) DataArray: Normalized Intensity values mapped to boolean array in (2) (2) DataArray: Integer boolean array for Bragg Peak positions mapped to intensity array dimensions (3) Attributes: Values of theta_x, theta_y, hkl_extent, sigma_theta, sigma_phi, sigma_chi, resolution, CIF file, DOI reference Within the DataSet, we will store multiple DataArrays that each correspond to a different simulation. Should we store the simulation results with respect to an access CIF/POSCAR file? (Algorithm Development): Is it possible to use singular value decomposition (SVD) in conjunction with simulating a lower resolution/dimensionality 2D GIWAXS image to improve image quality to high resolution simulations while retaining the effective computational efficiency of the low resolution simulation? 11. (Create Method/Widget): Add a second interactive table in WAXSPeakSelect.py UI to view selected/highlighted grouped/ungrouped peaks, and peaks assigned to a CIF/POSCAR filepath. 12. (Update Method) in WAXSReduce.py 'WAXSReduce' and 'Interpolation1D(WAXSReduce)' Class methods: Update formatting in WAXSReduce plotting methods to have LaTeX axis labels. Requires aliasing for different plotting coordinate options. (Algorithm Development) in WAXSSearch.py: Explore usage of intensity-weighted K-Dimensional Tree binary clustering routine in WAXSSearch 2D peak finding routine. An example of class diagram: classDiagram Person <|-- Student Person <|-- Professor Person : +String name Person : +String phoneNumber Person : +String emailAddress Person: +purchaseParkingPass() Address \"1\" <-- \"0..1\" Person:lives at class Student{ +int studentNumber +int averageMark +isEligibleToEnrol() +getSeminarsTaken() } class Professor{ +int salary } class Address{ +String street +String city +String state +int postalCode +String country -validate() +outputAsLabel() } An example of the table: Method Description GET Fetch resource PUT Update resource DELETE Delete resource","title":"pyWAXS"},{"location":"GIWAXS/pyWAXS/#pywaxs","text":"","title":"pyWAXS"},{"location":"GIWAXS/pyWAXS/#pywaxs-our-groups-python-based-giwaxs-data-reduction-and-analysis-package","text":"We intend for this module to include working UI (user interface) deployable executable(s) to assist with 2D GIWAXS data reduction, peak search & analysis, WAXS image simulation from (CIF/POSCAR) files, and reverse GIWAXS problem solving capabilities.","title":"pyWAXS: Our group's Python-based GIWAXS data reduction and analysis package."},{"location":"GIWAXS/pyWAXS/#program-structure","text":"stateDiagram-v2 pyFAI --> Load pyFAI: (-zsh) pyFAI-calib2 pyFAI: - Create PONI Calibrant (.poni) pyFAI: - Create MASK (.edf) Load --> WAXSTransform Load: (jupyter) Load GIWAXS Data Load: - TIFF Datafile (.tiff) Load: - Mask (.edf, .json file) Load: - PONI Calibrant (.poni file) Parameters --> WAXSTransform Parameters: (jupyter) Input Parameters Parameters: - X-ray Energy (keV) Parameters: - Metadata Keys Parameters: - Incidence Angle (deg.) WAXSTransform: (class) WAXSTransform WAXSTransform: - Create Detector Object (PONI, MASK) WAXSTransform: - Apply Ewald Sphere Corrections WAXSTransform: - Perform pyFAI Image Caking WAXSTransform --> WAXSReduce WAXSReduce: (class) WAXSReduce WAXSReduce: - Store Image Data (Raw, Recip, Caked Data) WAXSReduce: - Image Processing/Corrections WAXSReduce: - Image Plotting WAXSReduce: - Export & Reload Processed Data (netCDF4) WAXSReduce --> WAXSSearch WAXSSearch: (class) WAXSSearch WAXSSearch: - 2D Peak Finder WAXSSearch --> WAXSPeakSelect WAXSPeakSelect: (UI) WAXSPeakSelect WAXSPeakSelect: - Manual Peak 'Cleaning' WAXSPeakSelect: - Peak Grouping WAXSPeakSelect --> WAXSReverse WAXSReverse --> WAXSAnalyze WAXSReverse: (class) WAXSReverse WAXSReverse: GIWAXS Reverse Solving Tool Parameters2: Input Parameters Parameters2: (jupyter) Input Parameters Parameters2: - Load CIF(s)/POSCAR Files Parameters2: - Select Initial Simulation Parameters Parameters2 --> WAXSDiffSim WAXSDiffSim: (class) WAXSDiffSim WAXSDiffSim: GIWAXS Simulation Tool WAXSDiffSim --> WAXSAnalyze WAXSAnalyze: (class) WAXSAnalyze WAXSAnalyze: Compare Simulated & Measured Bragg Peak Positions WAXSAnalyze --> Output Output: Output Output: - (Known Phases) Phase Orientation, Miller Indices, Crystallite Dispersity Output: - (Unknown Phases) Reciprocal Space Lattice Vectors, Miller Indices","title":"Program Structure"},{"location":"GIWAXS/pyWAXS/#pywaxs-development-task-list","text":"Zihan 0. (Create Method) in WAXSReduce.py Subclass 'Integration1D(WAXSReduce)': Direct azimuthal integrator on reciprocal space map (no caking or pixel splitting). Integration will rely on data assignment for masked positions (NaN v. '0' v. '-1') - see Keith's 'Task 0'. 1. (Update Method) in WAXSReduce.py 'WAXSReduce' Class Method 'sinchi_corr': Review and update method 'sinchi_corr' used for sin(chi) correction. Check on usage and physical sample requirements for applying q^2 term. Check on application of sin(chi) correction factor in existing method. 2. (Algorithm Development/Update/Create Class Methods) in WAXSReverse.py 'WAXSReverse' Class: Create functional class methods for WAXSReverse brute force solver workflow to be implemented in a Jupyter notebook. Notebook user should be able to reloaded peak sets stored as netCDF4 (h5netcdf) files from WAXSPeakSelect.py UI exports (peak position, caked image, reciprocal space map xarray Datasets). See Keith task bullet points 1 & 2. 3. (Create Method) in WAXSReduce.py Class 'ImageInterpolator': Create a new Fourier transform class method for the image interpolation class that is presently saved in the WAXSReduce.py script. Keith 0. (Confirm Implementation): Check WAXSReduce Class methods, are mask regions being stored as '0', '-1', None, or NaN values in the DataArray/DataSets being stored as class attributes. 1. (Create Class Methods) in WAXSPeakSelect.py Classes: Create class methods to export a netCDF4 (h5netcdf) file from an active UI experiment session. User will be able to add/remove peaks from peak search outputs and export these peaks to a reloadable file format to the WAXSReverse.py 'WAXSReverse' Class. 2. (Create Class Methods) in WAXSReverse.py 'WAXSReverse' Class: Create a netCDF4 (h5netcdf) file loader for outputted Xarray DataSets to load sets of reduced data and paired peak positions from WAXSPeakSelect.py UI exports. 3. (Create Method) in WAXSPeakSelect.py MyCanvas(FigureCanvas) Class Method(s): Display Sliced ROI selection from DataArray for Integration1D(WAXSReduce) subclass method connections in UI. 4. (Update Documentation): (README) for local environment installation using Conda installation and mounted 'pyWAXS.yml' file. 5. (Add Documentation): Add a folder 'example' that contains example data/PONI/MASK/POSCAR files for data analysis. 6. (Update Method): Fix highlighting tool in WAXSPeakSelect.py UI, add (X) box. 7. (Create Method/Widget): Add an interactive table in WAXSPeakSelect.py UI to view selected/highlighted peaks in a group within a table. 8. (Create Method/Widget): Add buttons to 'Group' peaks in WAXSPeakSelect.py and select qxy, qz layer line binning in secondary table (later task). 9. (Create Method/Widget): Add method to load a CIF/POSCAR filepath as attribute into WAXSSim window. 10. (Update Methods): Update 'WAXSSim' class methods to work using Xarray Datasets, we will use sets of chunks to store our data. Each chunk will contain: (1) DataArray: Normalized Intensity values mapped to boolean array in (2) (2) DataArray: Integer boolean array for Bragg Peak positions mapped to intensity array dimensions (3) Attributes: Values of theta_x, theta_y, hkl_extent, sigma_theta, sigma_phi, sigma_chi, resolution, CIF file, DOI reference Within the DataSet, we will store multiple DataArrays that each correspond to a different simulation. Should we store the simulation results with respect to an access CIF/POSCAR file? (Algorithm Development): Is it possible to use singular value decomposition (SVD) in conjunction with simulating a lower resolution/dimensionality 2D GIWAXS image to improve image quality to high resolution simulations while retaining the effective computational efficiency of the low resolution simulation? 11. (Create Method/Widget): Add a second interactive table in WAXSPeakSelect.py UI to view selected/highlighted grouped/ungrouped peaks, and peaks assigned to a CIF/POSCAR filepath. 12. (Update Method) in WAXSReduce.py 'WAXSReduce' and 'Interpolation1D(WAXSReduce)' Class methods: Update formatting in WAXSReduce plotting methods to have LaTeX axis labels. Requires aliasing for different plotting coordinate options. (Algorithm Development) in WAXSSearch.py: Explore usage of intensity-weighted K-Dimensional Tree binary clustering routine in WAXSSearch 2D peak finding routine. An example of class diagram: classDiagram Person <|-- Student Person <|-- Professor Person : +String name Person : +String phoneNumber Person : +String emailAddress Person: +purchaseParkingPass() Address \"1\" <-- \"0..1\" Person:lives at class Student{ +int studentNumber +int averageMark +isEligibleToEnrol() +getSeminarsTaken() } class Professor{ +int salary } class Address{ +String street +String city +String state +int postalCode +String country -validate() +outputAsLabel() } An example of the table: Method Description GET Fetch resource PUT Update resource DELETE Delete resource","title":"pyWAXS Development Task List"},{"location":"RSoXS/Contrast_function/","text":"The contrast of RSoXS is strongly dependent on the dispersion ( \\(\\delta\\) ) and the absorption ( \\(\\beta\\) ) components of the refractive index (n) as represented in the equations below. The refractive index [ \\(n(E)\\) ] at a photon energy \\(E\\) can be calculated using equation: \\[\\begin{equation} \\begin{aligned} n(E)=&1-\\delta(E)+i\\beta(E)\\\\ =&1-\\frac{r_0}{2\\pi}\\lambda^2\\sum_j N_j[f_{1j}(E)+if_{2j}(E)] \\end{aligned} \\label{eq:contrast1} \\end{equation}\\] The contrast function ( \\(C\\) ) can be estimated from equation: \\begin{equation} C\\propto{(\\Delta n)^2}\\propto{(\\Delta\\delta)^2+(\\Delta\\beta)^2} \\label{eq:contrast2} \\end{equation} Where \\(r_0\\) is the classical electron radius, \\(\\lambda\\) is the wavelength of incident X-rays, \\(N_M\\) the number density of an atom ( \\(M\\) ), \\(f_1\\) and \\(f_2\\) are the real and imaginary parts of the complex atomic scattering factor, and the summation is performed for all atoms ( \\(M\\) ). Kramers\u2013Kronig relations: \\begin{equation} \\chi_1(\\omega)=\\frac{1}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{\\omega^{\\prime} \\chi_2\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime}+\\frac{\\omega}{\\pi} \\mathcal{P} \\int_{-\\infty}^{\\infty} \\frac{\\chi_2\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime} \\end{equation} \\[\\begin{equation} \\chi_2(\\omega)=-\\frac{2}{\\pi} \\mathcal{P} \\int_0^{\\infty} \\frac{\\omega \\chi_1\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime}=-\\frac{2 \\omega}{\\pi} \\mathcal{P} \\int_0^{\\infty} \\frac{\\chi_1\\left(\\omega^{\\prime}\\right)}{\\omega^{\\prime 2}-\\omega^2} d \\omega^{\\prime} \\end{equation}\\]","title":"Contrast function"},{"location":"Rigaku/intro/","text":"ConvertRASX \u00b6 Extracts image from Rigaku .rasx format and converts it to .tiff and .jpg Julian Mars ( julian.mars@outlook.com ) Import Defs Path import numpy as np import matplotlib.pyplot as plt from zipfile import ZipFile from PIL import Image from pathlib import Path from glob import glob import io as io def open_rasx ( fname ): \"\"\" Opens rigaku .rasx image files. File structure is as following: .rasx -> zip -root.xml -DataN -ImageX.bin -MesurementConditions0.xml \"\"\" with ZipFile ( fname ) as myzip : with myzip . open ( 'Data0/Image0.bin' ) as myfile : im = np . frombuffer ( myfile . read (), dtype = 'uint32' , ) . reshape ( 385 , 775 ) with myzip . open ( 'Data0/MesurementConditions0.xml' ) as myfile : header = myfile . read () . decode () return im , header def save_tif ( fname , im ): im = Image . fromarray ( im ) im . save ( fname ) folder = Path ( '/Users/zihanzhang/Library/CloudStorage/OneDrive-UCB-O365' ) Convert all Rasx files in the folder: Code for f in glob ( str ( folder ) + '/*.rasx' ): print ( f ) f = Path ( f ) im , header = open_rasx ( f ) #inverse 1st axis im = im [:: - 1 ,:] im = np . log ( im ) plt . imshow ( im ) plt . savefig ( f . with_suffix ( '.jpg' ), dpi = 360 ) plt . show () save_tif ( f . with_suffix ( '.tiff' ), im ) Converted image","title":"Rasx to image file"},{"location":"Rigaku/intro/#convertrasx","text":"Extracts image from Rigaku .rasx format and converts it to .tiff and .jpg Julian Mars ( julian.mars@outlook.com ) Import Defs Path import numpy as np import matplotlib.pyplot as plt from zipfile import ZipFile from PIL import Image from pathlib import Path from glob import glob import io as io def open_rasx ( fname ): \"\"\" Opens rigaku .rasx image files. File structure is as following: .rasx -> zip -root.xml -DataN -ImageX.bin -MesurementConditions0.xml \"\"\" with ZipFile ( fname ) as myzip : with myzip . open ( 'Data0/Image0.bin' ) as myfile : im = np . frombuffer ( myfile . read (), dtype = 'uint32' , ) . reshape ( 385 , 775 ) with myzip . open ( 'Data0/MesurementConditions0.xml' ) as myfile : header = myfile . read () . decode () return im , header def save_tif ( fname , im ): im = Image . fromarray ( im ) im . save ( fname ) folder = Path ( '/Users/zihanzhang/Library/CloudStorage/OneDrive-UCB-O365' ) Convert all Rasx files in the folder: Code for f in glob ( str ( folder ) + '/*.rasx' ): print ( f ) f = Path ( f ) im , header = open_rasx ( f ) #inverse 1st axis im = im [:: - 1 ,:] im = np . log ( im ) plt . imshow ( im ) plt . savefig ( f . with_suffix ( '.jpg' ), dpi = 360 ) plt . show () save_tif ( f . with_suffix ( '.tiff' ), im ) Converted image","title":"ConvertRASX"},{"location":"Tools/salt/","text":"Perovskite Salt Weight Calculator \u00b6 Main Defs ######### user input ######### MA = 1 Cs = 0 FA = 0 Pb = 1 Br = 1.5 I = 1.5 Cl = 0 Molarity = 1 # M volume = 3 # ml ########### b = np . array ([ MA , Cs , FA , Pb , Br , I , Cl ]) give_me_recipe ( b , Molarity * volume ) import numpy as np import itertools import math def solver ( A , b ): return np . transpose ( np . matmul ( np . linalg . inv ( A ), b )) def generate_combinations ( a , b ): nums = [ 1 ] * a + [ 0 ] * ( b - a ) unique_permutations = set ( itertools . permutations ( nums )) result = [ list ( perm ) for perm in unique_permutations ] return result def remove_zero_columns ( A , b ): A = np . array ( A ) b = np . array ( b ) non_zero_indices = np . nonzero ( b )[ 0 ] new_A = A [:, non_zero_indices ] return new_A def replace_ones_with_values ( a , b ): a_index = 0 new_b = [] for value in b : if value == 1 : new_b . append ( a [ a_index ]) a_index += 1 else : new_b . append ( value ) return new_b def compu_reduction ( remove_x , A , b , Chemical_List , Element_List ): n = 0 Chemical_List_remove_index = [] for i in Chemical_List : if remove_x in i : Chemical_List_remove_index . append ( n ) n = n + 1 Chemical_List = np . delete ( Chemical_List , Chemical_List_remove_index , axis = 0 ) A = np . delete ( A , Chemical_List_remove_index , axis = 0 ) n = 0 for i in Element_List : if remove_x in i : A = np . delete ( A , n , axis = 1 ) b = np . delete ( b , n ) n = n + 1 Element_List . remove ( remove_x ) return A , b , Chemical_List , Element_List def give_me_recipe ( b , mmol ): Chemical_List = [ 'MACl' , 'CsCl' , 'FACl' , 'MAI' , 'MABr' , 'CsI' , 'CsBr' , 'FAI' , 'FABr' , 'PbI2' , 'PbBr2' , 'PbCl2' ] Chemical_weight = { 'MACl' : 67.52 , 'CsCl' : 168.36 , 'FACl' : 80.52 , 'MAI' : 158.97 , 'MABr' : 111.97 , 'CsI' : 259.81 , 'CsBr' : 212.81 , 'FAI' : 172.00 , 'FABr' : 125.00 , 'PbI2' : 461.00 , 'PbBr2' : 367.00 , 'PbCl2' : 278.11 } Element_List0 = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] Element_List = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] if abs ( b [ 0 ] + b [ 1 ] + b [ 2 ] + 2 * b [ 3 ] - b [ 4 ] - b [ 5 ] - b [ 6 ]) > 0.0001 : print ( 'The charge is not balanced.' ) # print('Are you kidding me?') else : A = np . array ([[ 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 2 , 0 ], [ 0 , 0 , 0 , 1 , 2 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 2 ]]) n = 0 for i in b : if i == 0 : A , b , Chemical_List , Element_List = compu_reduction ( Element_List0 [ n ], A , b , Chemical_List , Element_List ) n = n + 1 A = np . transpose ( A ) b = np . transpose ( b ) cb = generate_combinations ( np . linalg . matrix_rank ( A ), A . shape [ 1 ]) para0 = [] for i in cb : new_A = remove_zero_columns ( A , i ) if np . linalg . matrix_rank ( new_A ) == np . linalg . matrix_rank ( A ): slt = solver ( new_A [: - 1 ], b [: - 1 ]) if np . min ( slt ) >= 0 : para = replace_ones_with_values ( slt , i ) para0 . append ( para ) para0 = np . round ( np . array ( para0 ), 5 ) para0 = np . unique ( para0 , axis = 0 ) recipe_N = 0 for i in para0 : n = 0 recipe_N = recipe_N + 1 print ( 'Recipe #' , recipe_N ) for j in i : if j != 0 : print ( Chemical_List [ n ], j , ',' , np . round ( j * Chemical_weight [ Chemical_List [ n ]] * mmol , 5 ), 'mg' ) n = n + 1 print () Output: Recipe # 1 MABr 1.0 , 335.91 mg PbI2 0.75 , 1037.25 mg PbBr2 0.25 , 275.25 mg Recipe # 2 MAI 1.0 , 476.91 mg PbI2 0.25 , 345.75 mg PbBr2 0.75 , 825.75 mg","title":"Perovskite salt weight calculator"},{"location":"Tools/salt/#perovskite-salt-weight-calculator","text":"Main Defs ######### user input ######### MA = 1 Cs = 0 FA = 0 Pb = 1 Br = 1.5 I = 1.5 Cl = 0 Molarity = 1 # M volume = 3 # ml ########### b = np . array ([ MA , Cs , FA , Pb , Br , I , Cl ]) give_me_recipe ( b , Molarity * volume ) import numpy as np import itertools import math def solver ( A , b ): return np . transpose ( np . matmul ( np . linalg . inv ( A ), b )) def generate_combinations ( a , b ): nums = [ 1 ] * a + [ 0 ] * ( b - a ) unique_permutations = set ( itertools . permutations ( nums )) result = [ list ( perm ) for perm in unique_permutations ] return result def remove_zero_columns ( A , b ): A = np . array ( A ) b = np . array ( b ) non_zero_indices = np . nonzero ( b )[ 0 ] new_A = A [:, non_zero_indices ] return new_A def replace_ones_with_values ( a , b ): a_index = 0 new_b = [] for value in b : if value == 1 : new_b . append ( a [ a_index ]) a_index += 1 else : new_b . append ( value ) return new_b def compu_reduction ( remove_x , A , b , Chemical_List , Element_List ): n = 0 Chemical_List_remove_index = [] for i in Chemical_List : if remove_x in i : Chemical_List_remove_index . append ( n ) n = n + 1 Chemical_List = np . delete ( Chemical_List , Chemical_List_remove_index , axis = 0 ) A = np . delete ( A , Chemical_List_remove_index , axis = 0 ) n = 0 for i in Element_List : if remove_x in i : A = np . delete ( A , n , axis = 1 ) b = np . delete ( b , n ) n = n + 1 Element_List . remove ( remove_x ) return A , b , Chemical_List , Element_List def give_me_recipe ( b , mmol ): Chemical_List = [ 'MACl' , 'CsCl' , 'FACl' , 'MAI' , 'MABr' , 'CsI' , 'CsBr' , 'FAI' , 'FABr' , 'PbI2' , 'PbBr2' , 'PbCl2' ] Chemical_weight = { 'MACl' : 67.52 , 'CsCl' : 168.36 , 'FACl' : 80.52 , 'MAI' : 158.97 , 'MABr' : 111.97 , 'CsI' : 259.81 , 'CsBr' : 212.81 , 'FAI' : 172.00 , 'FABr' : 125.00 , 'PbI2' : 461.00 , 'PbBr2' : 367.00 , 'PbCl2' : 278.11 } Element_List0 = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] Element_List = [ 'MA' , 'Cs' , 'FA' , 'Pb' , 'Br' , 'I' , 'Cl' ] if abs ( b [ 0 ] + b [ 1 ] + b [ 2 ] + 2 * b [ 3 ] - b [ 4 ] - b [ 5 ] - b [ 6 ]) > 0.0001 : print ( 'The charge is not balanced.' ) # print('Are you kidding me?') else : A = np . array ([[ 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 2 , 0 ], [ 0 , 0 , 0 , 1 , 2 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 2 ]]) n = 0 for i in b : if i == 0 : A , b , Chemical_List , Element_List = compu_reduction ( Element_List0 [ n ], A , b , Chemical_List , Element_List ) n = n + 1 A = np . transpose ( A ) b = np . transpose ( b ) cb = generate_combinations ( np . linalg . matrix_rank ( A ), A . shape [ 1 ]) para0 = [] for i in cb : new_A = remove_zero_columns ( A , i ) if np . linalg . matrix_rank ( new_A ) == np . linalg . matrix_rank ( A ): slt = solver ( new_A [: - 1 ], b [: - 1 ]) if np . min ( slt ) >= 0 : para = replace_ones_with_values ( slt , i ) para0 . append ( para ) para0 = np . round ( np . array ( para0 ), 5 ) para0 = np . unique ( para0 , axis = 0 ) recipe_N = 0 for i in para0 : n = 0 recipe_N = recipe_N + 1 print ( 'Recipe #' , recipe_N ) for j in i : if j != 0 : print ( Chemical_List [ n ], j , ',' , np . round ( j * Chemical_weight [ Chemical_List [ n ]] * mmol , 5 ), 'mg' ) n = n + 1 print () Output: Recipe # 1 MABr 1.0 , 335.91 mg PbI2 0.75 , 1037.25 mg PbBr2 0.25 , 275.25 mg Recipe # 2 MAI 1.0 , 476.91 mg PbI2 0.25 , 345.75 mg PbBr2 0.75 , 825.75 mg","title":"Perovskite Salt Weight Calculator"},{"location":"tags/","text":"Tags \u00b6 Following is a list of relevant tags:","title":"Tags"},{"location":"tags/#tags","text":"Following is a list of relevant tags:","title":"Tags"}]}